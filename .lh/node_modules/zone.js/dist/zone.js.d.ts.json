{
    "sourceFile": "node_modules/zone.js/dist/zone.js.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1703608268099,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1703608268099,
            "name": "Commit-0",
            "content": "/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <amd-module name=\"angular/packages/zone.js/lib/zone\" />\n/**\n * Suppress closure compiler errors about unknown 'global' variable\n * @fileoverview\n * @suppress {undefinedVars}\n */\n/**\n * Zone is a mechanism for intercepting and keeping track of asynchronous work.\n *\n * A Zone is a global object which is configured with rules about how to intercept and keep track\n * of the asynchronous callbacks. Zone has these responsibilities:\n *\n * 1. Intercept asynchronous task scheduling\n * 2. Wrap callbacks for error-handling and zone tracking across async operations.\n * 3. Provide a way to attach data to zones\n * 4. Provide a context specific last frame error handling\n * 5. (Intercept blocking methods)\n *\n * A zone by itself does not do anything, instead it relies on some other code to route existing\n * platform API through it. (The zone library ships with code which monkey patches all of the\n * browsers's asynchronous API and redirects them through the zone for interception.)\n *\n * In its simplest form a zone allows one to intercept the scheduling and calling of asynchronous\n * operations, and execute additional code before as well as after the asynchronous task. The rules\n * of interception are configured using [ZoneConfig]. There can be many different zone instances in\n * a system, but only one zone is active at any given time which can be retrieved using\n * [Zone#current].\n *\n *\n *\n * ## Callback Wrapping\n *\n * An important aspect of the zones is that they should persist across asynchronous operations. To\n * achieve this, when a future work is scheduled through async API, it is necessary to capture, and\n * subsequently restore the current zone. For example if a code is running in zone `b` and it\n * invokes `setTimeout` to scheduleTask work later, the `setTimeout` method needs to 1) capture the\n * current zone and 2) wrap the `wrapCallback` in code which will restore the current zone `b` once\n * the wrapCallback executes. In this way the rules which govern the current code are preserved in\n * all future asynchronous tasks. There could be a different zone `c` which has different rules and\n * is associated with different asynchronous tasks. As these tasks are processed, each asynchronous\n * wrapCallback correctly restores the correct zone, as well as preserves the zone for future\n * asynchronous callbacks.\n *\n * Example: Suppose a browser page consist of application code as well as third-party\n * advertisement code. (These two code bases are independent, developed by different mutually\n * unaware developers.) The application code may be interested in doing global error handling and\n * so it configures the `app` zone to send all of the errors to the server for analysis, and then\n * executes the application in the `app` zone. The advertising code is interested in the same\n * error processing but it needs to send the errors to a different third-party. So it creates the\n * `ads` zone with a different error handler. Now both advertising as well as application code\n * create many asynchronous operations, but the [Zone] will ensure that all of the asynchronous\n * operations created from the application code will execute in `app` zone with its error\n * handler and all of the advertisement code will execute in the `ads` zone with its error handler.\n * This will not only work for the async operations created directly, but also for all subsequent\n * asynchronous operations.\n *\n * If you think of chain of asynchronous operations as a thread of execution (bit of a stretch)\n * then [Zone#current] will act as a thread local variable.\n *\n *\n *\n * ## Asynchronous operation scheduling\n *\n * In addition to wrapping the callbacks to restore the zone, all operations which cause a\n * scheduling of work for later are routed through the current zone which is allowed to intercept\n * them by adding work before or after the wrapCallback as well as using different means of\n * achieving the request. (Useful for unit testing, or tracking of requests). In some instances\n * such as `setTimeout` the wrapping of the wrapCallback and scheduling is done in the same\n * wrapCallback, but there are other examples such as `Promises` where the `then` wrapCallback is\n * wrapped, but the execution of `then` is triggered by `Promise` scheduling `resolve` work.\n *\n * Fundamentally there are three kinds of tasks which can be scheduled:\n *\n * 1. [MicroTask] used for doing work right after the current task. This is non-cancelable which is\n *    guaranteed to run exactly once and immediately.\n * 2. [MacroTask] used for doing work later. Such as `setTimeout`. This is typically cancelable\n *    which is guaranteed to execute at least once after some well understood delay.\n * 3. [EventTask] used for listening on some future event. This may execute zero or more times, with\n *    an unknown delay.\n *\n * Each asynchronous API is modeled and routed through one of these APIs.\n *\n *\n * ### [MicroTask]\n *\n * [MicroTask]s represent work which will be done in current VM turn as soon as possible, before VM\n * yielding.\n *\n *\n * ### [MacroTask]\n *\n * [MacroTask]s represent work which will be done after some delay. (Sometimes the delay is\n * approximate such as on next available animation frame). Typically these methods include:\n * `setTimeout`, `setImmediate`, `setInterval`, `requestAnimationFrame`, and all browser specific\n * variants.\n *\n *\n * ### [EventTask]\n *\n * [EventTask]s represent a request to create a listener on an event. Unlike the other task\n * events they may never be executed, but typically execute more than once. There is no queue of\n * events, rather their callbacks are unpredictable both in order and time.\n *\n *\n * ## Global Error Handling\n *\n *\n * ## Composability\n *\n * Zones can be composed together through [Zone.fork()]. A child zone may create its own set of\n * rules. A child zone is expected to either:\n *\n * 1. Delegate the interception to a parent zone, and optionally add before and after wrapCallback\n *    hooks.\n * 2. Process the request itself without delegation.\n *\n * Composability allows zones to keep their concerns clean. For example a top most zone may choose\n * to handle error handling, while child zones may choose to do user action tracking.\n *\n *\n * ## Root Zone\n *\n * At the start the browser will run in a special root zone, which is configured to behave exactly\n * like the platform, making any existing code which is not zone-aware behave as expected. All\n * zones are children of the root zone.\n *\n */\ninterface Zone {\n    /**\n     *\n     * @returns {Zone} The parent Zone.\n     */\n    parent: Zone | null;\n    /**\n     * @returns {string} The Zone name (useful for debugging)\n     */\n    name: string;\n    /**\n     * Returns a value associated with the `key`.\n     *\n     * If the current zone does not have a key, the request is delegated to the parent zone. Use\n     * [ZoneSpec.properties] to configure the set of properties associated with the current zone.\n     *\n     * @param key The key to retrieve.\n     * @returns {any} The value for the key, or `undefined` if not found.\n     */\n    get(key: string): any;\n    /**\n     * Returns a Zone which defines a `key`.\n     *\n     * Recursively search the parent Zone until a Zone which has a property `key` is found.\n     *\n     * @param key The key to use for identification of the returned zone.\n     * @returns {Zone} The Zone which defines the `key`, `null` if not found.\n     */\n    getZoneWith(key: string): Zone | null;\n    /**\n     * Used to create a child zone.\n     *\n     * @param zoneSpec A set of rules which the child zone should follow.\n     * @returns {Zone} A new child zone.\n     */\n    fork(zoneSpec: ZoneSpec): Zone;\n    /**\n     * Wraps a callback function in a new function which will properly restore the current zone upon\n     * invocation.\n     *\n     * The wrapped function will properly forward `this` as well as `arguments` to the `callback`.\n     *\n     * Before the function is wrapped the zone can intercept the `callback` by declaring\n     * [ZoneSpec.onIntercept].\n     *\n     * @param callback the function which will be wrapped in the zone.\n     * @param source A unique debug location of the API being wrapped.\n     * @returns {function(): *} A function which will invoke the `callback` through [Zone.runGuarded].\n     */\n    wrap<F extends Function>(callback: F, source: string): F;\n    /**\n     * Invokes a function in a given zone.\n     *\n     * The invocation of `callback` can be intercepted by declaring [ZoneSpec.onInvoke].\n     *\n     * @param callback The function to invoke.\n     * @param applyThis\n     * @param applyArgs\n     * @param source A unique debug location of the API being invoked.\n     * @returns {any} Value from the `callback` function.\n     */\n    run<T>(callback: Function, applyThis?: any, applyArgs?: any[], source?: string): T;\n    /**\n     * Invokes a function in a given zone and catches any exceptions.\n     *\n     * Any exceptions thrown will be forwarded to [Zone.HandleError].\n     *\n     * The invocation of `callback` can be intercepted by declaring [ZoneSpec.onInvoke]. The\n     * handling of exceptions can be intercepted by declaring [ZoneSpec.handleError].\n     *\n     * @param callback The function to invoke.\n     * @param applyThis\n     * @param applyArgs\n     * @param source A unique debug location of the API being invoked.\n     * @returns {any} Value from the `callback` function.\n     */\n    runGuarded<T>(callback: Function, applyThis?: any, applyArgs?: any[], source?: string): T;\n    /**\n     * Execute the Task by restoring the [Zone.currentTask] in the Task's zone.\n     *\n     * @param task to run\n     * @param applyThis\n     * @param applyArgs\n     * @returns {*}\n     */\n    runTask(task: Task, applyThis?: any, applyArgs?: any): any;\n    /**\n     * Schedule a MicroTask.\n     *\n     * @param source\n     * @param callback\n     * @param data\n     * @param customSchedule\n     */\n    scheduleMicroTask(source: string, callback: Function, data?: TaskData, customSchedule?: (task: Task) => void): MicroTask;\n    /**\n     * Schedule a MacroTask.\n     *\n     * @param source\n     * @param callback\n     * @param data\n     * @param customSchedule\n     * @param customCancel\n     */\n    scheduleMacroTask(source: string, callback: Function, data?: TaskData, customSchedule?: (task: Task) => void, customCancel?: (task: Task) => void): MacroTask;\n    /**\n     * Schedule an EventTask.\n     *\n     * @param source\n     * @param callback\n     * @param data\n     * @param customSchedule\n     * @param customCancel\n     */\n    scheduleEventTask(source: string, callback: Function, data?: TaskData, customSchedule?: (task: Task) => void, customCancel?: (task: Task) => void): EventTask;\n    /**\n     * Schedule an existing Task.\n     *\n     * Useful for rescheduling a task which was already canceled.\n     *\n     * @param task\n     */\n    scheduleTask<T extends Task>(task: T): T;\n    /**\n     * Allows the zone to intercept canceling of scheduled Task.\n     *\n     * The interception is configured using [ZoneSpec.onCancelTask]. The default canceler invokes\n     * the [Task.cancelFn].\n     *\n     * @param task\n     * @returns {any}\n     */\n    cancelTask(task: Task): any;\n}\ninterface ZoneType {\n    /**\n     * @returns {Zone} Returns the current [Zone]. The only way to change\n     * the current zone is by invoking a run() method, which will update the current zone for the\n     * duration of the run method callback.\n     */\n    current: Zone;\n    /**\n     * @returns {Task} The task associated with the current execution.\n     */\n    currentTask: Task | null;\n    /**\n     * Verify that Zone has been correctly patched. Specifically that Promise is zone aware.\n     */\n    assertZonePatched(): void;\n    /**\n     *  Return the root zone.\n     */\n    root: Zone;\n    /**\n    * load patch for specified native module, allow user to\n    * define their own patch, user can use this API after loading zone.js\n    */\n    __load_patch(name: string, fn: _PatchFn): void;\n    /**\n     * Zone symbol API to generate a string with __zone_symbol__ prefix\n     */\n    __symbol__(name: string): string;\n}\n/**\n * Patch Function to allow user define their own monkey patch module.\n */\ndeclare type _PatchFn = (global: Window, Zone: ZoneType, api: _ZonePrivate) => void;\n/**\n * _ZonePrivate interface to provide helper method to help user implement\n * their own monkey patch module.\n */\ninterface _ZonePrivate {\n    currentZoneFrame: () => _ZoneFrame;\n    symbol: (name: string) => string;\n    scheduleMicroTask: (task?: MicroTask) => void;\n    onUnhandledError: (error: Error) => void;\n    microtaskDrainDone: () => void;\n    showUncaughtError: () => boolean;\n    patchEventTarget: (global: any, apis: any[], options?: any) => boolean[];\n    patchOnProperties: (obj: any, properties: string[] | null, prototype?: any) => void;\n    patchThen: (ctro: Function) => void;\n    setNativePromise: (nativePromise: any) => void;\n    patchMethod: (target: any, name: string, patchFn: (delegate: Function, delegateName: string, name: string) => (self: any, args: any[]) => any) => Function | null;\n    bindArguments: (args: any[], source: string) => any[];\n    patchMacroTask: (obj: any, funcName: string, metaCreator: (self: any, args: any[]) => any) => void;\n    patchEventPrototype: (_global: any, api: _ZonePrivate) => void;\n    isIEOrEdge: () => boolean;\n    ObjectDefineProperty: (o: any, p: PropertyKey, attributes: PropertyDescriptor & ThisType<any>) => any;\n    ObjectGetOwnPropertyDescriptor: (o: any, p: PropertyKey) => PropertyDescriptor | undefined;\n    ObjectCreate(o: object | null, properties?: PropertyDescriptorMap & ThisType<any>): any;\n    ArraySlice(start?: number, end?: number): any[];\n    patchClass: (className: string) => void;\n    wrapWithCurrentZone: (callback: any, source: string) => any;\n    filterProperties: (target: any, onProperties: string[], ignoreProperties: any[]) => string[];\n    attachOriginToPatched: (target: any, origin: any) => void;\n    _redefineProperty: (target: any, callback: string, desc: any) => void;\n    patchCallbacks: (api: _ZonePrivate, target: any, targetName: string, method: string, callbacks: string[]) => void;\n    getGlobalObjects: () => {\n        globalSources: any;\n        zoneSymbolEventNames: any;\n        eventNames: string[];\n        isBrowser: boolean;\n        isMix: boolean;\n        isNode: boolean;\n        TRUE_STR: string;\n        FALSE_STR: string;\n        ZONE_SYMBOL_PREFIX: string;\n        ADD_EVENT_LISTENER_STR: string;\n        REMOVE_EVENT_LISTENER_STR: string;\n    } | undefined;\n}\n/**\n * _ZoneFrame represents zone stack frame information\n */\ninterface _ZoneFrame {\n    parent: _ZoneFrame | null;\n    zone: Zone;\n}\ninterface UncaughtPromiseError extends Error {\n    zone: Zone;\n    task: Task;\n    promise: Promise<any>;\n    rejection: any;\n}\n/**\n * Provides a way to configure the interception of zone events.\n *\n * Only the `name` property is required (all other are optional).\n */\ninterface ZoneSpec {\n    /**\n     * The name of the zone. Useful when debugging Zones.\n     */\n    name: string;\n    /**\n     * A set of properties to be associated with Zone. Use [Zone.get] to retrieve them.\n     */\n    properties?: {\n        [key: string]: any;\n    };\n    /**\n     * Allows the interception of zone forking.\n     *\n     * When the zone is being forked, the request is forwarded to this method for interception.\n     *\n     * @param parentZoneDelegate Delegate which performs the parent [ZoneSpec] operation.\n     * @param currentZone The current [Zone] where the current interceptor has been declared.\n     * @param targetZone The [Zone] which originally received the request.\n     * @param zoneSpec The argument passed into the `fork` method.\n     */\n    onFork?: (parentZoneDelegate: ZoneDelegate, currentZone: Zone, targetZone: Zone, zoneSpec: ZoneSpec) => Zone;\n    /**\n     * Allows interception of the wrapping of the callback.\n     *\n     * @param parentZoneDelegate Delegate which performs the parent [ZoneSpec] operation.\n     * @param currentZone The current [Zone] where the current interceptor has been declared.\n     * @param targetZone The [Zone] which originally received the request.\n     * @param delegate The argument passed into the `wrap` method.\n     * @param source The argument passed into the `wrap` method.\n     */\n    onIntercept?: (parentZoneDelegate: ZoneDelegate, currentZone: Zone, targetZone: Zone, delegate: Function, source: string) => Function;\n    /**\n     * Allows interception of the callback invocation.\n     *\n     * @param parentZoneDelegate Delegate which performs the parent [ZoneSpec] operation.\n     * @param currentZone The current [Zone] where the current interceptor has been declared.\n     * @param targetZone The [Zone] which originally received the request.\n     * @param delegate The argument passed into the `run` method.\n     * @param applyThis The argument passed into the `run` method.\n     * @param applyArgs The argument passed into the `run` method.\n     * @param source The argument passed into the `run` method.\n     */\n    onInvoke?: (parentZoneDelegate: ZoneDelegate, currentZone: Zone, targetZone: Zone, delegate: Function, applyThis: any, applyArgs?: any[], source?: string) => any;\n    /**\n     * Allows interception of the error handling.\n     *\n     * @param parentZoneDelegate Delegate which performs the parent [ZoneSpec] operation.\n     * @param currentZone The current [Zone] where the current interceptor has been declared.\n     * @param targetZone The [Zone] which originally received the request.\n     * @param error The argument passed into the `handleError` method.\n     */\n    onHandleError?: (parentZoneDelegate: ZoneDelegate, currentZone: Zone, targetZone: Zone, error: any) => boolean;\n    /**\n     * Allows interception of task scheduling.\n     *\n     * @param parentZoneDelegate Delegate which performs the parent [ZoneSpec] operation.\n     * @param currentZone The current [Zone] where the current interceptor has been declared.\n     * @param targetZone The [Zone] which originally received the request.\n     * @param task The argument passed into the `scheduleTask` method.\n     */\n    onScheduleTask?: (parentZoneDelegate: ZoneDelegate, currentZone: Zone, targetZone: Zone, task: Task) => Task;\n    onInvokeTask?: (parentZoneDelegate: ZoneDelegate, currentZone: Zone, targetZone: Zone, task: Task, applyThis: any, applyArgs?: any[]) => any;\n    /**\n     * Allows interception of task cancellation.\n     *\n     * @param parentZoneDelegate Delegate which performs the parent [ZoneSpec] operation.\n     * @param currentZone The current [Zone] where the current interceptor has been declared.\n     * @param targetZone The [Zone] which originally received the request.\n     * @param task The argument passed into the `cancelTask` method.\n     */\n    onCancelTask?: (parentZoneDelegate: ZoneDelegate, currentZone: Zone, targetZone: Zone, task: Task) => any;\n    /**\n     * Notifies of changes to the task queue empty status.\n     *\n     * @param parentZoneDelegate Delegate which performs the parent [ZoneSpec] operation.\n     * @param currentZone The current [Zone] where the current interceptor has been declared.\n     * @param targetZone The [Zone] which originally received the request.\n     * @param hasTaskState\n     */\n    onHasTask?: (parentZoneDelegate: ZoneDelegate, currentZone: Zone, targetZone: Zone, hasTaskState: HasTaskState) => void;\n}\n/**\n *  A delegate when intercepting zone operations.\n *\n *  A ZoneDelegate is needed because a child zone can't simply invoke a method on a parent zone. For\n *  example a child zone wrap can't just call parent zone wrap. Doing so would create a callback\n *  which is bound to the parent zone. What we are interested in is intercepting the callback before\n *  it is bound to any zone. Furthermore, we also need to pass the targetZone (zone which received\n *  the original request) to the delegate.\n *\n *  The ZoneDelegate methods mirror those of Zone with an addition of extra targetZone argument in\n *  the method signature. (The original Zone which received the request.) Some methods are renamed\n *  to prevent confusion, because they have slightly different semantics and arguments.\n *\n *  - `wrap` => `intercept`: The `wrap` method delegates to `intercept`. The `wrap` method returns\n *     a callback which will run in a given zone, where as intercept allows wrapping the callback\n *     so that additional code can be run before and after, but does not associate the callback\n *     with the zone.\n *  - `run` => `invoke`: The `run` method delegates to `invoke` to perform the actual execution of\n *     the callback. The `run` method switches to new zone; saves and restores the `Zone.current`;\n *     and optionally performs error handling. The invoke is not responsible for error handling,\n *     or zone management.\n *\n *  Not every method is usually overwritten in the child zone, for this reason the ZoneDelegate\n *  stores the closest zone which overwrites this behavior along with the closest ZoneSpec.\n *\n *  NOTE: We have tried to make this API analogous to Event bubbling with target and current\n *  properties.\n *\n *  Note: The ZoneDelegate treats ZoneSpec as class. This allows the ZoneSpec to use its `this` to\n *  store internal state.\n */\ninterface ZoneDelegate {\n    zone: Zone;\n    fork(targetZone: Zone, zoneSpec: ZoneSpec): Zone;\n    intercept(targetZone: Zone, callback: Function, source: string): Function;\n    invoke(targetZone: Zone, callback: Function, applyThis?: any, applyArgs?: any[], source?: string): any;\n    handleError(targetZone: Zone, error: any): boolean;\n    scheduleTask(targetZone: Zone, task: Task): Task;\n    invokeTask(targetZone: Zone, task: Task, applyThis?: any, applyArgs?: any[]): any;\n    cancelTask(targetZone: Zone, task: Task): any;\n    hasTask(targetZone: Zone, isEmpty: HasTaskState): void;\n}\ndeclare type HasTaskState = {\n    microTask: boolean;\n    macroTask: boolean;\n    eventTask: boolean;\n    change: TaskType;\n};\n/**\n * Task type: `microTask`, `macroTask`, `eventTask`.\n */\ndeclare type TaskType = 'microTask' | 'macroTask' | 'eventTask';\n/**\n * Task type: `notScheduled`, `scheduling`, `scheduled`, `running`, `canceling`, 'unknown'.\n */\ndeclare type TaskState = 'notScheduled' | 'scheduling' | 'scheduled' | 'running' | 'canceling' | 'unknown';\n/**\n */\ninterface TaskData {\n    /**\n     * A periodic [MacroTask] is such which get automatically rescheduled after it is executed.\n     */\n    isPeriodic?: boolean;\n    /**\n     * Delay in milliseconds when the Task will run.\n     */\n    delay?: number;\n    /**\n     * identifier returned by the native setTimeout.\n     */\n    handleId?: number;\n}\n/**\n * Represents work which is executed with a clean stack.\n *\n * Tasks are used in Zones to mark work which is performed on clean stack frame. There are three\n * kinds of task. [MicroTask], [MacroTask], and [EventTask].\n *\n * A JS VM can be modeled as a [MicroTask] queue, [MacroTask] queue, and [EventTask] set.\n *\n * - [MicroTask] queue represents a set of tasks which are executing right after the current stack\n *   frame becomes clean and before a VM yield. All [MicroTask]s execute in order of insertion\n *   before VM yield and the next [MacroTask] is executed.\n * - [MacroTask] queue represents a set of tasks which are executed one at a time after each VM\n *   yield. The queue is ordered by time, and insertions can happen in any location.\n * - [EventTask] is a set of tasks which can at any time be inserted to the end of the [MacroTask]\n *   queue. This happens when the event fires.\n *\n */\ninterface Task {\n    /**\n     * Task type: `microTask`, `macroTask`, `eventTask`.\n     */\n    type: TaskType;\n    /**\n     * Task state: `notScheduled`, `scheduling`, `scheduled`, `running`, `canceling`, `unknown`.\n     */\n    state: TaskState;\n    /**\n     * Debug string representing the API which requested the scheduling of the task.\n     */\n    source: string;\n    /**\n     * The Function to be used by the VM upon entering the [Task]. This function will delegate to\n     * [Zone.runTask] and delegate to `callback`.\n     */\n    invoke: Function;\n    /**\n     * Function which needs to be executed by the Task after the [Zone.currentTask] has been set to\n     * the current task.\n     */\n    callback: Function;\n    /**\n     * Task specific options associated with the current task. This is passed to the `scheduleFn`.\n     */\n    data?: TaskData;\n    /**\n     * Represents the default work which needs to be done to schedule the Task by the VM.\n     *\n     * A zone may choose to intercept this function and perform its own scheduling.\n     */\n    scheduleFn?: (task: Task) => void;\n    /**\n     * Represents the default work which needs to be done to un-schedule the Task from the VM. Not all\n     * Tasks are cancelable, and therefore this method is optional.\n     *\n     * A zone may chose to intercept this function and perform its own un-scheduling.\n     */\n    cancelFn?: (task: Task) => void;\n    /**\n     * @type {Zone} The zone which will be used to invoke the `callback`. The Zone is captured\n     * at the time of Task creation.\n     */\n    readonly zone: Zone;\n    /**\n     * Number of times the task has been executed, or -1 if canceled.\n     */\n    runCount: number;\n    /**\n     * Cancel the scheduling request. This method can be called from `ZoneSpec.onScheduleTask` to\n     * cancel the current scheduling interception. Once canceled the task can be discarded or\n     * rescheduled using `Zone.scheduleTask` on a different zone.\n     */\n    cancelScheduleRequest(): void;\n}\ninterface MicroTask extends Task {\n    type: 'microTask';\n}\ninterface MacroTask extends Task {\n    type: 'macroTask';\n}\ninterface EventTask extends Task {\n    type: 'eventTask';\n}\ndeclare const Zone: ZoneType;\n"
        }
    ]
}